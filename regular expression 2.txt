复习：
\b：单词的开头或结尾，只能匹配一个位置
. ：除了换行符以外的任意字符
* :任意数量
.*:任意数量除换行符以外的任意字符
\bhi\b.*\bLucy\b的意思就是：显示单词hi 然后是任意个任意字符(除换行符) 最后是lucy这个单词
\d匹配的是单个数字
0\d\d-\d\d\d\d\d\d\d\d：
一般写作0\d{2}-\d{8}
{2}：指的是前面的字符重复匹配2次
\s匹配任意空白符，包括空格，制表符，换行符，中文全角空格
|w匹配字母或数字或下划线或汉字等
\ba\w*\b匹配：以a开头的字符
\d+：匹配的是一个或多个数字组成的数字
\b\w{6}\b：有六个字符的字符串
^匹配字符串的开始。匹配一个位置
&匹配字符串的结束。匹配一个位置
^\d{5,12}$ ：匹配的是5到12位数字
unibetter\.com :匹配的是unibetter.com
C:\\windows :匹配的是C:\windows
? ：重复零次或一次
{n} :重复n次
{n,} :重复n次或更多次
{n,m} :重复n次到m次
Windows\d+匹配Windows后面跟1个或更多数字
^\w+ 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)
“(”和“)”也是元字符，所以需要匹配它们的话需要转义
像[aeiou]就匹配任何一个英文元音字母
[.?!]匹配标点符号(.或?或!)。
[0-9]代表的含意与\d就是完全一致的：一位数字
[a-z0-9A-Z_]也完全等同于\w
\(?0\d{2}[) -]?\d{8} (010)88886666，或022-22334455，或02912345678等
<***********************复习结束***********>

分支条件能解决刚才那个问题：
正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开
0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。

\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}
匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。
\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。
之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。
原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。
写一个匹配IP的正则表达式：(\d{1,3}\.){3}\d{1,3}
但是它也将888.999.777.666等不可能存在的IP地址匹配了，但是正则表达式不提供任何数学的功能，所以只能使用冗长的分组
所以正确匹配的姿势是：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
反义代码：
代码/语法	说明
\W	匹配任意不是字母，数字，下划线，汉字的字符
\S	匹配任意不是空白符的字符
\D	匹配任意非数字的字符
\B	匹配不是单词开头或结束的位置
[^x]	匹配除了x以外的任意字符
[^aeiou]	匹配除了aeiou这几个字母以外的任意字符

\S+匹配:不包含空格的字符串
<a[^>]+> ：匹配用尖括号括起来的以a开头的后面不出现尖括号的一段字符

\b(\w+)\b\s+\1\b：匹配的是：
 \1：代表分组1匹配的文本。
 \b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。
 这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，
 这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。
 
也可以指定一个子表达式的组名，使用这样的语法：(?<Word>\w+)(或者把尖括号换成'也行：(?'Word'\w+)),这样就把\w+的组名指定为Word了。
要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。

表4.常用分组语法
分类	代码/语法	说明
捕获	(exp)	匹配exp,并捕获文本到自动命名的组里
(?<name>exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
(?:exp)	匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言	(?=exp)	匹配exp前面的位置
(?<=exp)	匹配exp后面的位置
(?!exp)	匹配后面跟的不是exp的位置
(?<!exp)	匹配前面不是exp的位置
注释	(?#comment)	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
 
正则表达式零宽断言详解
1、断言用来申明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。
接下来的四个用于查找在某些内容之前或之后的东西，也就是说他们像\b,^,$那样用于指定一个位置，
这个位置应该满足一定的条件(即断言),因此他们也被称为零宽断言。

(?=exp) 也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。
比如:\b\w+(?=ing\b),匹配以ing结尾的单词的前面部分，如查找I'm singing while you're dancing
他会匹配danc和sing

(?<=exp) 也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。
比如：(?<=\bre)\w+\b 匹配以re开头的单词的后半部分(除re以外的部分)，例如在查找reading a book时，它匹配ading。
假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：
((?<=\d)\d{3})*\b，用它对1234567890进行查找时结果是234567890。
(?<=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。


注释：小括号的另外一种用途是注释(?#comment)来包含注释。例如：
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。

当正则表达式中包含能接受重复的限定符时，通常的行为是(在使整个表达式能得到匹配的前提下)匹配
尽可能多的字符。考虑到这个表达式：a.*b，它将会匹配最长的以a开头，以b结束的字符串。如果用它来搜索aabab的话
他会匹配整个字符aabab，这被称为贪婪匹配。
有时我们需要懒惰匹配，也就是匹配尽可能少的字符。其前面给出的限定符都可以被转化为懒惰匹配模式，
只要在它后面加上一个问号？。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。

a.*?b	：匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，他会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。
*? :重复任意次，但尽可能少重复
+? :重复一次或更多次，但尽可能少重复
?? :重复0次或一次，但尽可能少重复
{n,m}?重复n到m次，但尽可能少重复
{n,}? :重复n次以上，但尽可能少重复



在c#中，你可以使用Regex(String,RegexOptions)构造函数来设置正则表达式的处理选项.
Regex = regex = new Regex("\ba\w{6}\b",RegexOption.IgnoreCase);
IgnoreCase(忽略大小写):匹配时不区分大小写
Multiline (多行模式):更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
Singleline(单行模式):更改.的含义，使它与每一个字符匹配(包括换行符\n)
IgnorePatternWhitespace(忽略空白)忽略表达式中的非转义空白并启用由#标记的注释。
RightToLeft(从右向左查找):匹配从右向左而不是从左向右进行。
ExplicitCapture(显式捕获)仅捕获已被显式命名的组。
ECMAScript(JavaScript兼容模式):使表达式的行为与它在JavaScript里的行为一致。







